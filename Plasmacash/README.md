
# Plasma Cash Chain

Plasma Cash rootchain contract implementation by @wolkinc.  For background, please read:

* [Plasma Cash with Sparse Merkle Trees, Bloom filters, and Probabilistic Transfers](https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers/2006)

* [Plasma Cash Simple Spec](https://karl.tech/plasma-cash-simple-spec/)

* [Plasma Cash: Plasma with much less user data checking](https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298)

* [Plasma-ERC721: Loom Network's Plasma Implementation using our SMT](https://ethresear.ch/t/loom-network-plasma-cash-for-erc721-tokens/2385)

## Resources

* A 10 block, 6 tokens Simulation log can be found  [here](https://gist.github.com/mkchungs/d06e325408d503795f39e96e716752be)

* [RootContract](https://rinkeby.etherscan.io/address/0x31dbfc0b2fa2f649c23d45f52408ce1189f52b35#readContract): Link to our feature-complete plasmacash-mvp contract on Rinkeby

* [wolk-Plasma](https://github.com/wolkdb/plasma): A separate repository to our Go-based plasma Chain (*code will be made public after security auditing*)

* [swarmdb](https://github.com/wolkdb/swarmdb): Main repository to our decentralized database v0.1 release

* [API](https://docs.wolk.com/): documentation of exposed swarmdb API interface

## Contacts

Any feedback/suggestion would be greatly appreciated!
Email: michael@wolk.com

## Contract Interface

* [TxHash](https://rinkeby.etherscan.io/address/0x5009d14a7a9648ef8b1ec723fffc855c425f9c62#readContract): This library handles rlp txhash and verifies a transaction's validity by checking (1) recipient matches with depositor when prevBlock is 0 or (2) signer matches with prevOwner otherwise.

* [SparseMerkle Tree](https://rinkeby.etherscan.io/address/0xda4d188831b6c67140cefec35f540bacd87ba526#readContract): This contract is implemented based on [succinct sparse merkle proof format](https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers) we published on ethresearch.


## Events on MainNet: Deposits, Exits, and Challenges

We define plasma nodes as a set of nodes that are responsible of (1) monitoring events {`Deposits`, `Exits`, `Challenges`} happening on RootChain contract and recording those state changes on Plasma (2) accepting RPC requests for tokenID transfers on Plasma Chain. Among all nodes, one "main" node and multiple "stand-by" nodes are strategically selected as "Leader" group with additional responsibilities of publishing block info {Sparse Merkle Root, BloomFilter Hash} periodically on the RootChain contract.

Generally speaking, plasma nodes are required to be online at all time and watch any incoming RootChain event using Web Socket; if a plasma node temporarily went offline and wants to rejoin the network, it must catch up to the latest state on MainNet by retrieving all the missing past events via RPC calls with filter options.  A list of event classes that need responding to are:

* `PublishedBlock`: events generated by Plasma Leader calling `submitBlock(blockNumber, merkleRoot Hash)`. Every PublishedBlock event includes the `currentDepositIndex` at given blockNumber, which can be used by plasma nodes to filter a list of unprocessed deposits on plasma chain.  

* `Deposit`: events generated by users depositing ETH(WLK) into RootChain contract. Plasma nodes call `initDeposit()` on plasma chain and sign-off valid tokenIDs to the depositors. Periodically, a plasma block containing all RootChain `deposit()` and all token transfers occurred on plasma chain _*since last published block*_ should be minted, resulting in a new `submitBlock` call by the Plasma Leader.

* `StartExit` and `DepositExit`: events generated by users trying to withdraw tokenIDs they claim to have ownership for. Malicious/frivolous exits can be immediately challenged by the anyone, while valid exits should result in a plasma node subsequently responding with the tokenID as being _untransferrable_ in a `sendPlasmaTransaction` call.

* `ChallengeExit`: ChallengeExit currently _does not_ have any event. A valid challenge remove the tokenID from pending exitsQueue made by illegitimate owner; restrictions on such token be immediately lifted. e.g. marking the tokenID _transferrable_ in a `sendPlasmaTransaction` call.  

* `FinalizeExit`: all tokens finalized can be taken out of circulation completely; the plasma node should respond with the tokenID as being _exited_

# Plasma Node
To run a plasma node:
```
# build plasma
$ make plasma

# run plasma node, peer with master, neighbors, etc.
$ ./build/bin/plasma --verbosity 4 --datadir ~/Library/Ethereum/
Deposit:  TokenId b437230feb2d24db | Denomination 1000000000000000000 | DepositIndex 0  (Depositor: 0xA45b77a98E2B840617e2eC6ddfBf71403bdCb683)
Deposit:  TokenId 37b01bd3adfc4ef3 | Denomination 1000000000000000000 | DepositIndex 1  (Depositor: 0x82Da88C31E874C678D529ad51E43De3A4BAF3914)
Deposit:  TokenId b76883d225414136 | Denomination 2000000000000000000 | DepositIndex 2  (Depositor: 0x3088666E05794d2498D9d98326c1b426c9950767)
Deposit:  TokenId 9af84bc1208918b | Denomination 3000000000000000000 | DepositIndex 3  (Depositor: 0xBef06CC63C8f81128c26efeDD461A9124298092b)
Deposit:  TokenId 7c00dfa72e8832ed | Denomination 4000000000000000000 | DepositIndex 4  (Depositor: 0x74f978A3E049688777E6120D293F24348BDe5fA6)
Deposit:  TokenId 5fb1eec526dc7a1e | Denomination 5000000000000000000 | DepositIndex 5  (Depositor: 0x59B66c66b9159b62DaFCB5fEde243384DFca076D)
...
which will start off with some sample deposits
```

*Note*: [wolk-Plasma core](https://github.com/wolkdb/plasma) backend are yet to be released after security audit.

## RPC Interface
Plasma nodes serve its users ("wolk" nodes) with RPC calls that can be tested on the console:
```
# Launch console
$ ./build/bin/plasma attach ~/Library/Ethereum/plasmachain.ipc
> plasma
{
  getPlasmaBalance: function(),
  getPlasmaBlock: function(),
  getPlasmaBloomFilter: function(),
  getPlasmaToken: function(),
  getPlasmaTransactionPool: function(),
  getPlasmaTransactionReceipt: function(),
  sendPlasmaTransaction: function()
}
```
This JSON-RPC API implements the following concepts:

* `getPlasmaBalance(address)` - get a list of tokenIDs, denominations, and total balance owned by address(account).  This might go into a "Wallet" abstraction, to start up your own token list, where any tokenID in the Wallet could be verified.

```
> plasma.getPlasmaBalance("0x82Da88C31E874C678D529ad51E43De3A4BAF3914")
{
  balance: 1000000000000000000,
    tokens: [
        {
            "token": 4012737863958155000,
            "denomination": 1
        }
    ]
}
```

* `getPlasmaToken(common.Hash)` - get token Info by tokenID. This can used by a node to verify token ownership when receiving a token from sender.
```
> plasma.getPlasmaToken("0x000000000000000000000000000000000000000000000000b437230feb2d24db")
{
  denomination: 1000000000000000000,
  depositIndex: 0,
  depositor: "0xa45b77a98e2b840617e2ec6ddfbf71403bdcb683",
  lastBlock: 0,
  owner: "0xa45b77a98e2b840617e2ec6ddfbf71403bdcb683",
  prevBlock: 0,
  tokenID: "b437230feb2d24db"
}
```
_TODO: convert 256bit to 64-bit_

* `getPlasmaBloomFilter(hash)` - get Bloom Filter by hash. Bloom Filter is required for a node to efficiently validate token transfers.
```
> plasma.getPlasmaBloomFilter("0xb0208d37df54df90cfd7d4418f1f22cf64e02ae6024897fd7078eea9a4198d75")
{
  filter: "00000000000000000000000000000010..."}
```

* `getPlasmaBlock(uint)` - get Plasma BlockInfo by blockNumber. A Plasma block can be used to verify an incoming token transfer.
```
> plasma.getPlasmaBlock("0x2")
{
  accountRoot: "0x0daeb2dac72936f803418662070302684a2059f4027eb9cc01e0377550c546e1",
  blockNumber: "0000000000000002",
  bloomID: "0xda0f9b66e614309fead8740a3f318fd4864a09462753b0db8ae5004c7d7bfa68",
  merkleRoot: "0xea88a855f552ebfbb717731c580b9b7270404dd3cfd10bd533006a41eadab564",
  transactionRoot: "0x8915934f8e580fd81a5e8c2664a4d49e28463e06177bf6662ee866ef844d3290"
}
> plasma.getPlasmaBlock(0x1);
> plasma.getPlasmaBlock(1);
```

* `getPlasmaTransactionReceipt(hash)`  - get transaction Info {receipt, proof, token history} by txHash. The receipt can be used to check whether a transaction actually was successful.  The sender could send this back to the recipient, or the recipient could just call this to retrieve the proof.
```
> plasma.getPlasmaTransactionReceipt("0x5ed6c927c7c2d74e6a533eb642b1ebc2ed0992321918e8f0180634cf125674ed");
{
  blockNumber: 0,
  receipt: 0
}
```

## Token Transfer

When one node sends a Plasma token to another:

1. The sender (who must have the full history of the token to-be-sent) submits a JSON RPC `sendPlasmaTransaction` request to a plasma node.  A plasma node relay such request to its peers via `BroadcastPlasmaTransaction`, one of whom is a leader and will run `MintPlasmaBlock` within a few seconds (e.g. after 3 seconds, or after 1000 transactions, whichever comes first). While the pending transaction sit in the transaction pool, tx hash is returned back to sender immediately. Furthermore, calling `getPlasmaTransactionReceipt` won't return anything until the tx is mined:
```
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, recipient: "0x3088666E05794d2498D9d98326c1b426c9950767", prevOwner: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x55b3b7f32330082b76c2070393ae0735ce6e365f78611e9b0c3bbc100344a817"
> plasma.getPlasmaToken("0x00000000000000000000000000000000000000000000000037b01bd3adfc4ef3")
{
  denomination: 1000000000000000000,
  depositIndex: 1,
  depositor: "0x82da88c31e874c678d529ad51e43de3a4baf3914",
  lastBlock: 2,
  owner: "0x82da88c31e874c678d529ad51e43de3a4baf3914",
  prevBlock: 1,
  tokenID: "37b01bd3adfc4ef3"
}
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, prevOwner: "0x3088666E05794d2498D9d98326c1b426c9950767", recipient: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x0fea1b85ec1f95eccd4f25fbe8d5762175f9ec644d91aa0d9e8cef9d63f1272e"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, recipient: "0x3088666E05794d2498D9d98326c1b426c9950767", prevOwner: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x2d16dfdced116f6726ead3ea06daba25850410e85dec7ceb1b6775507c454b26"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, prevOwner: "0x3088666E05794d2498D9d98326c1b426c9950767", recipient: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0xe2c5687d5c4ff148acda9e4ac5803707e0346b98583b2f236db6621719c90d5f"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, recipient: "0x3088666E05794d2498D9d98326c1b426c9950767", prevOwner: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x30ad968f0ab70bd58008cede1162e3312b9be563c93270930d247a5487c99e94"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, prevOwner: "0x3088666E05794d2498D9d98326c1b426c9950767", recipient: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0xb7362f69aa2d1153ebcac0181929523ff01e1f1dcafb7af3c5c1f5582d037a81"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, recipient: "0x3088666E05794d2498D9d98326c1b426c9950767", prevOwner: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x39972c6aa936c361d05d0417853cac758a3010ef373f7df4ac2c0f622df65d75"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, prevOwner: "0x3088666E05794d2498D9d98326c1b426c9950767", recipient: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0x0b757851d60523236df7c56ae578bc34d0f145cf1fb5bd43ea64a4f9af5d7bda"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, recipient: "0x3088666E05794d2498D9d98326c1b426c9950767", prevOwner: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0xad572d03f09851625b6ad5ac4baa06891a7c60860a046fd37c6b1bb15228bccd"
> plasma.sendPlasmaTransaction({tokenId:0x37b01bd3adfc4ef3, prevOwner: "0x3088666E05794d2498D9d98326c1b426c9950767", recipient: "0x82Da88C31E874C678D529ad51E43De3A4BAF3914"});
"0xbd8b8cc179857b757e4a8943676eadefd60bb560b62b8ece85fe692ae99292f2"
```

2. When new Blocks are created (with Transactions referencing tokens, bloom filter) by the leader, it does a call to `submitBlock` on MainNet, but only _after_ it uses the `PlasmaChunkstore` abstraction to verifiably store at least:
 * 1 `Block`, key (for now): Merkle Root
 * 1 `BloomFilter`, key: the bloom filter hash
 * n `Transaction`, key: the transactionHash

When this happens, `getPlasmaTransactionReceipt` can return a full response with the success/failure outcome.  The leader then does a `BroadcastBlock` to all the plasma nodes.


3. The sender, having seen its transaction "clear" with the plasma operator (and seeing that it has a "proof of inclusion" on MainNet), can then send a "proof" to its fellow node by calling `getPlasmaTransactionReceipt` and sending the data with its own _SWAP_ protocol.  The recipient will then:
 * calling `getPlasmaTransactionReceipt` itself, retrieving the token history
 * check the signature matches the sender
 * check the transaction has been included in the block by calling MainNet for the proof (this is free!)
 * download all Bloom filters, all the way back to the original deposit of the token
 * For false-positive case in Bloom filters or non-empty blocks, check for token history.
 * update its own Wallet
